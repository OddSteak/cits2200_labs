# CITS2200 Exercise 1: Sorting and Searching

Implement all the function stubs in `sorting.py` and `searching.py`.

You are encouraged to write your own tests, and to compare your implementations with other students and attempt to break each other's implementations.

Remember the objective is for you to understand the logic behind these algorithms.
It is not sufficient to simply end up with working code, or be able to explain the algorithms step by step.
Your understanding should be sufficient that you can apply these logical ideas to novel problems in the future.

You should be able to write a logical argument for the correctness and time complexity of each algorithm.
Practise doing so, and see if other students and lab facilitators find your arguments convincing.
You argument should be sufficient to convince a fellow student who has never seen this algorithm before of its correctness.

Consider the following questions.
You are encouraged to discuss them with other students:
1. Are there any scenarios in which insertion sort would be faster than merge sort?
2. If you need to find a single element in a list, is it worth sorting then binary searching? How many elements would we need to be searching for to make it worth it?
3. How might you find the smallest 100 elements of a large unsorted list?
4. Could you use binary search to find the turning point of a parabola? How?
